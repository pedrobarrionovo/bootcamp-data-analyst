
 
EQUIPE
Anderson Melo
Aska Pereira
Diego Aguiar
Jessica Staudt
Pedro Barrionovo
Rosana Santos

 
SUMÁRIO

•	OBJETIVOS
•	SOBRE OS DADOS
•	METODOLOGIA
•	FLUXO DE TRABALHO (WORKFLOW)
•	ANÁLISE DE DADOS
•	ESCOLHA DOS DADOS
•	MATRIZ SWOT
•	PERGUNTAS DE NEGÓCIO
•	POWER BI
•	ESTRUTURA DO CÓDIGO ETL
•	SQL CAGED
•	SQL PNAD-C
•	SQL Censo 2010
•	COLAB IPEA
•	CÓDIGO ETL
•	IPEA | Colab - Pandas e PySpark
•	CAGED, PNAD-C e Censo 2012
•	REFERÊNCIAS

 
1.	Objetivos

O objetivo desse projeto tem como compreender o mercado de trabalho no Brasil, abordando o panorama geral do mercado de trabalho formal no Brasil entre os anos de 2012 e 2022, buscando saber as movimentações dos registros com CLT/CNPJ e dos informais, realizando um comparativo do mercado de trabalho formal e informal enquanto explora as características demográficas da população do país. Além disso, busca-se entender como o mercado de trabalho se comportou durante o período de 10 anos, incluindo uma análise breve do impacto da COVID-19 e como se encontra o mercado de trabalho pós-pandemia.
Em relação à população brasileira, este projeto visa abordar as diferenças de gênero, raciais, salariais, educacionais e sobre a inclusão e a participação de pessoas com deficiência no mercado de trabalho. Explora-se como a população está inserida no mercado de trabalho e quem são as pessoas que têm a maior participação no mercado de trabalho formal.

2.	Sobre os dados

Os dados utilizados neste projeto foram encontrados no sítio eletrônico www.basedosdados.org , onde é possível encontrar diversas coleções de forma gratuita.
Dentre estas coleções, iremos utilizar as seguintes bases:
•	Cadastro Geral de Empregados e Desempregados – CAGED: contém os dados de demissão e admissão para aqueles registrados com CLT que ocorreram entre 2007 e vão até a presente data.
•	Pesquisa Nacional por Amostra de Domicílios Contínua (PNAD-C) – esta pesquisa é realizada pelo Instituto Brasileiro de Geografia e Estatística (IBGE) e possui dados produzidos continuamente sobre o mercado de trabalho, associadas a características demográficas e educacionais.
•	Instituto de Pesquisa Econômico Aplicado – IPEA: traz de forma trimestral os registros encontrados da PNAD-C que vai de março de 2012 até maio de 2023.
•	Censo 2010: feito pelo IBGE, traz dados sobre o Brasil na época de sua realização.

3.	Metodologia
Neste projeto foi utilizada a metodologia KDD (Knowledge Discovery in Databases) que é um processo para encontrar conhecimento em grandes conjuntos de dados. Ele envolve as seguintes etapas: definição do problema, coleta de dados, pré-processamento de dados, mineração de dados, interpretação dos resultados e avaliação dos resultados.  
O KDD é um processo iterativo, o que significa que as etapas podem ser repetidas várias vezes até que os resultados sejam satisfatórios. 
•	Seleção dos dados e Extração
o	Busca e acesso aos bancos de dados
o	Verificação do formato dos dados
o	Seleção e Extração dos dados para análise
o	Estratégias de análise

•	Pré-Processamento Big Query
o	Análise da qualidade dos dados
o	Integridade dos dados: limpeza, correção e remoção de dados inconsistentes 

•	Transformação dos dados Big Query e Python - Tratamento
o	Normalização, Padronização e Tradução dos dados
o	Redução dos dados
o	Visualização de gráficos Heatmap e Dispersão no PySpark
o	Carregamento dos dataframes resultantes na GCP e MongoDB

•	Modelagem dos dados
o	Dashboards do tipo Tático 
	Monitora desempenho mensal, com objetivos de decisões estratégicas por Gerentes
o	Modelagem dos Dashboard no Power BI

•	Interpretação e Avaliação dos padrões
o	Descoberta de Conhecimento (Conclusões e Insights)
o	Análise SWOT

4.	Fluxo de Trabalho (Workflow) 
 As bases de dados do CAGED, PNAD-C e Censo 2010 foram encontradas no www.basedosdados.org e acessadas via Big Query. Já a base de dados do IPEA foi encontrada no site do instituto, na seção de dados do órgão e extraída via download convencional.  
Após isto, foi feito o tratamento e transformação das bases maiores via SQL devido a impossibilidade de carregar via script em Python utilizando o Colab.  Já a base do Ipea, foi tratada com script em Python utilizando o Colab com as ferramentas Pandas e PySpark, além do metplotlib.
Para dar saída nessas bases, utilizamos uma biblioteca da base dos dados para realizar o download das bases tratados diretamente no Google Drive que depois foi passado para o Google Cloud Plataform (GCP) pelo Cloud Storage utilizando a bucket. Após isso, realizamos a conexão com a BigQuery para podermos utilizar dentro do Power BI que foi utilizado para a construção dos dashboards apresentados neste projeto.
Segue o fluxo de trabalho:
 

Abaixo, uma rápida descrição das ferramentas utilizadas neste projeto:
Google Colaboratory, também conhecido como Colaboratory ou simplesmente Colab, é um serviço gratuito baseado em nuvem que permite aos usuários criar e executar notebooks Jupyter em um navegador da web. Os notebooks são documentos interativos que podem conter texto, código, equações, gráficos e outros conteúdos. Eles são uma ótima maneira de compartilhar ideias e colaborar com outros.
Pandas é uma biblioteca de código aberto para análise de dados em Python. É projetado para trabalhar com dados estruturados, como tabelas de planilhas e arquivos CSV. O Pandas fornece uma variedade de recursos para manipular, analisar e visualizar dados.
PySpark é uma API Python para Apache Spark. Ele permite que os usuários escrevam e executem aplicativos Spark usando Python. O PySpark é uma ferramenta poderosa para processamento de dados em grande escala.
MongoDB é um banco de dados NoSQL orientado a documentos de código aberto, que é usado para armazenar e gerenciar grandes quantidades de dados. Ele é projetado para ser flexível e escalável, e é usado por uma ampla variedade de empresas, incluindo startups, grandes empresas e organizações governamentais.
Google Cloud Platform (GCP) é uma plataforma de computação em nuvem que oferece uma variedade de serviços, incluindo computação, armazenamento, rede, big data, machine learning, inteligência artificial, análise e muito mais. GCP é uma plataforma escalável e confiável que pode ajudar empresas de todos os tamanhos a criar e executar seus aplicativos em nuvem.
Google Cloud Storage é um serviço de armazenamento de objetos que permite armazenar e acessar dados de qualquer tamanho no Google Cloud Platform. O Cloud Storage é um serviço altamente escalável e confiável que pode ser usado para armazenar uma variedade de dados, incluindo imagens, vídeos, arquivos de log e dados de backup.
Google BigQuery é um data warehouse analítico totalmente gerenciado, sem servidor e baseado em nuvem do Google Cloud Platform que permite armazenar e analisar grandes conjuntos de dados estruturados. Ele pode lidar com até 1 petabyte por dia, e você só paga pelo que armazena e analisa. O BigQuery é ideal para empresas que precisam analisar grandes quantidades de dados para tomar decisões informadas.
Power BI é um conjunto de ferramentas de análise de negócios baseado em nuvem da Microsoft que ajuda os usuários a coletar, analisar e visualizar dados de uma variedade de fontes. Ele pode ser usado para criar relatórios, painéis e histórias de dados que podem ser compartilhados com outras pessoas.
5.	Análise dos Dados
5.1.	ESCOLHA DOS DADOS
As bases de dados para este trabalho foram escolhidas com o objetivo de enriquecer a análise de dados sobre o tema de "Mercado de Trabalho". 
O processo de escolha das bases de dados adotado pelo grupo refletiu a busca por informações relevantes que pudessem proporcionar uma compreensão abrangente sobre as dinâmicas do mercado de trabalho no contexto brasileiro. Além disso, o grupo também procurou bases de dados que possibilitassem ser feito um recorte temporal e social sobre minorias de representatividade no mercado de Trabalho do Brasil.
Para atender a esses objetivos, foram estabelecidas diretrizes específicas para a escolha das bases de dados:
1.	Abrangência Demográfica e Social: A fonte das bases de dados escolhidas foram o Censo (IBGE - Instituto Brasileiro de Geografia e Estatística) e o PNAD (Pesquisa Nacional por Amostra de Domicílio) para fornecer um panorama da população brasileira em relação a critérios cruciais, como Idade, Raça ou Cor, Gênero, Pessoa com Deficiência, Escolaridade e Estado. A inclusão dessas informações em números absolutos e porcentagens de amostragem garantiram uma visão ampla das características demográficas e sociais da população.

2.	Dinâmica do Mercado de Trabalho Formal: Para mostrar as movimentações de admissões e demissões dentro do mercado de trabalho formal no Brasil, a fonte das bases de dados usada foi do CAGED (Cadastro Geral de Desempregados e Empregados). Esta fonte permitiu ao grupo analisar tendências, flutuações e padrões de dados em números absolutos para entender a dinâmica do emprego formal no Brasil.

3.	Comparação entre Mercado Formal e Informal: A estratégica usada para explorar as diferenças e semelhanças entre esses dois aspectos essenciais da economia teve como fonte o IPEA (Instituto de Pesquisa Econômica Aplicada). Essa análise por amostragem foi valiosa para destacar as características distintas de ambos os setores.
Em resumo, as bases de dados selecionadas foram o resultado de uma avaliação criteriosa das opções de bases de dados disponíveis. Cada base forneceu dados para o grupo produzir insights valiosos sobre o mercado de trabalho no Brasil. As instituições que foram fontes para as bases de dados são amplamente reconhecidas por sua autoridade e rigor na coleta e disseminação de dados. 
Portanto, as bases de dados selecionadas ofereceram um arcabouço sólido para a pesquisa, permitindo que o grupo formulasse questões de pesquisa relevantes para conduzir análises sobre as dinâmicas do mercado de trabalho no contexto brasileiro. Além, de possibilitar ser feito um recorte temporal e social sobre minorias de representatividade no mercado de trabalho do Brasil.


5.2.	MATRIZ SWOT
FORÇAS
Diversidade Demográfica: A população brasileira é diversificada em termos de idade, gênero, raça e habilidades, o que pode ser um recurso valioso para a economia e a força de trabalho.
Reforma Trabalhista: A reforma trabalhista de 2017 trouxe flexibilidade para as relações de trabalho, o que pode incentivar a criação de empregos formais, permitindo adaptações às necessidades do mercado.	FRAQUEZAS
Desigualdades Sociais: O país enfrenta desigualdades no mercado de trabalho em relação a pessoas de deficientes, raça e gênero. 
Educação: Com as análises, foi possível identificar que a maioria da população brasileira se enquadra no nível fundamental incompleto e que a maioria da população que está trabalhando no mercado formal tem o ensino médio completo.
OPORTUNIDADES
Capacitação e Educação: Investir em educação e treinamento pode melhorar as habilidades da população e torná-la mais apta para empregos formais e qualificados.
Análise Comparativa: Comparar o mercado de trabalho formal e informal, bem como identificar as características demográficas, oferece a oportunidade de identificar disparidades e criar estratégias para reduzir essas diferenças.
	AMEAÇAS
Riscos de Saúde Pública: Eventos como pandemias (ex: COVID-19) podem impactar tanto o mercado formal quanto o informal, causando perda de empregos. 
Insegurança Econômica: A natureza instável do trabalho informal pode resultar em insegurança financeira, sem garantia de renda estável, benefícios ou proteção contra demissões.


5.3.	PERGUNTAS DE NEGÓCIO
Tendências de Emprego por Setor: Qual é a distribuição dos empregos por setor na economia brasileira ao longo dos anos? Quais setores estão crescendo ou diminuindo em termos de emprego? 
Taxas de Desemprego: Como as taxas de desemprego variam ao longo do tempo? Existem padrões sazonais ou tendências de longo prazo? 
Perfil do Emprego: Idade, gênero, raça, deficiência e nível de educação têm impacto nas oportunidades de emprego? 
Renda por Setor: Existem disparidades significativas de renda entre os setores? 
Diversidade Étnica: Como a população brasileira se autodeclara em termos étnicos? Quais são as proporções de diferentes grupos étnicos? 
Níveis de Educação: Qual é a distribuição dos níveis de educação na população? 
Proporção de Trabalho Formal e Informal: Qual é a proporção de empregos formais em comparação com empregos informais ao longo do tempo? Essa proporção varia entre diferentes setores da economia? 
Educação e Formalidade: Existe uma correlação entre o nível de educação e a probabilidade de um emprego ser formal? Os trabalhadores com maior educação têm mais chances de encontrar empregos formais? 
Evolução da Formalidade: Existem tendências ao longo do tempo que mostram mudanças na formalidade dos empregos? A formalidade está aumentando ou diminuindo? 
Gênero e Formalidade: Existe uma diferença de gênero na escolha entre empregos formais e informais? As mulheres são mais propensas a trabalhar em empregos informais? 
Taxa de Desemprego durante a Pandemia: Como a taxa de desemprego variou durante a pandemia? 
Informalidade: Com a pandemia, a informalidade aumentou ou diminuiu? 
5.4.	POWER BI 
Um dashboard é uma ferramenta que ajuda as empresas a acompanharem o desempenho de suas operações e tomar decisões baseadas em dados. O Power BI é um software que permite às empresas criarem dashboards personalizados para atender às suas necessidades específicas.
Ele oferece uma variedade de recursos que tornam possível criar dashboards atraentes e informativos. Os usuários podem conectar o Power BI a uma variedade de fontes de dados, incluindo bancos de dados, planilhas e arquivos CSV. Também oferece uma variedade de visualizações, incluindo gráficos, tabelas e mapas.
Os dashboards dentro dele podem ser usados para visualizar uma variedade de dados, incluindo vendas, marketing, finanças e operações. Podem ser usados para identificar tendências, padrões e oportunidades, além de serem usados para acompanhar o progresso em relação a metas e objetivos.
Abaixo estão os modelos criados por nossa equipe:
Dashboard Panorama do Brasil 01
 



Dashboard Panorama do Brasil 02
 
Dashboard Mercado de Trabalho Formal 01
 




Dashboard Mercado de Trabalho Formal 02
 
Dashboard Mercado de Trabalho Formal 03
 




Dashboard Mercado de Trabalho Formal 04
 
Dashboard Mercado de Trabalho Formal vs. Informal 01
 




Dashboard Mercado de Trabalho Formal vs. Informal 01
 
6.	ESTRUTURA DO CÓDIGO ETL 
Segue a estrutura do ETL feito no SQL e COLAB:
•	SQL para CAGED:
Tratamento
- Pré-análise e primeiros Insights
- Seleção dos atributos a serem utilizados na base
- Verificação de nulos e inconsistências dentro dos atributos selecionados
- Tradução
- Conversão de tipos
- Validação
Extração
Carregamento
•	SQL para PNAD-C:
Tratamento
- Pré-análise e primeiros Insights
- Seleção dos atributos a serem utilizados na base
- Verificação de nulos e inconsistências dentro dos atributos selecionados
- Tradução
- Conversão de tipos
- Validação
Extração
Carregamento
•	SQL para Censo 2010:
Tratamento
- Pré-análise e primeiros Insights
- Seleção dos atributos a serem utilizados na base
- Verificação de nulos e inconsistências dentro dos atributos selecionados
- Tradução
- Conversão de tipos
- Validação
Extração
Carregamento
•	COLAB IPEA:
Extração
Transformação
- Pré-análise
- Seleção das colunas a serem analisadas
- Tradução
- Verificação
- Verificação do schema via PySpark
- Carregamento
7.	CÓDIGO ETL 
•	CAGED, PNAD-C e Censo 2012
CAGED 2012 - 2019
Primeiramente será feita uma consulta para verificar quais são os atributos da tabela e verificar quais são os seus tipos.
SELECT
  column_name,
  data_type,
  is_nullable
FROM
  `basedosdados-staging.br_me_caged_staging.INFORMATION_SCHEMA.COLUMNS`
WHERE
  table_name = 'microdados_antigos';

 
É possível ver que todas as colunas da tabela são do tipo string. 
Para a análise foram escolhidos os seguintes atributos:
ano, sigla_uf, admitidos_desligados, salario_mensal, indicador_aprendiz, indicador_trabalho_intermitente, indicador_trabalho_parcial, indicador_portador_deficiencia, grau_instrucao, idade, sexo, raca_cor, subsetor_ibge.
A consulta a seguir irá verificar se o atributo “ano” possui alguma inconsistência como valores nulos, anos que não estão no formato correto (por exemplo, "212" em vez de "2012" ou "abc" em vez de um valor numérico), anos em formatos diferentes (como "2019" e "19" para o mesmo ano) ou anos que não estejam na cobertura temporal informada que seria de 2012 a 2019).
SELECT 
  ano AS Ano,
  COUNT(*) AS QTD
FROM `basedosdados-staging.br_me_caged_staging.microdados_antigos`
GROUP BY Ano
ORDER BY Ano ASC;



 
Nenhuma inconsistência foi verificada na coluna “ano”.
A consulta feita para o atributo “sigla_uf” tem por objetivo verificar inconsistências como verificar valores duplicados, ou seja, verificar se existem estados com a mesma sigla (mesmo estado escrito de forma diferente ou com diferentes grafias), verificar valores em branco, contabilizando todos os valores nulos que a coluna possui.
SELECT 
  sigla_uf,
  COUNT(*) AS QTD_SIGLA_UF
FROM `basedosdados-staging.br_me_caged_staging.microdados_antigos`
GROUP BY sigla_uf
ORDER BY sigla_uf ASC;

 
Nenhuma inconsistência foi verificada na coluna “sigla_uf”.
O atributo “admitidos_desligados” contempla as formas de admissão e desligamentos registradas. A consulta irá verificar as inconsistências como valores nulos e valores de código diferentes daqueles que estão descritos no dicionário fornecido pela fonte de dados.
SELECT 
  admitidos_desligados,
  COUNT(*) AS QTD_ADMITIDOS_DESLIGADOS
FROM `basedosdados-staging.br_me_caged_staging.microdados_antigos`
GROUP BY admitidos_desligados
ORDER BY admitidos_desligados ASC;

 
Nenhuma inconsistência foi verificada na coluna “admitidos_desligados”.
O atributo “salario_mensal” mostra os valores de salário associados a cada registro. A consulta irá verificar as inconsistências como valores nulos e valores que não sejam numéricos.
SELECT 
  salario_mensal,
  COUNT(*) AS QTD_SALARIO_MENSAL
FROM `basedosdados-staging.br_me_caged_staging.microdados_antigos`
GROUP BY salario_mensal
ORDER BY salario_mensal ASC;

 
Nenhuma inconsistência foi verificada na coluna “salario_mensal”, porém precisará trocar o seu tipo para INT64 em etapas futuras.
O atributo “indicador_aprendiz” mostra se o registro é referente a um aprendiz ou não. Os possíveis valores são “0” ou “1” e qual outro valor será considera uma inconsistência. 
SELECT 
  indicador_aprendiz,
  COUNT(*) AS QTD_INDICADOR_APRENDIZ
FROM `basedosdados-staging.br_me_caged_staging.microdados_antigos`
GROUP BY indicador_aprendiz
ORDER BY indicador_aprendiz ASC;

 

Nenhuma inconsistência foi verificada na coluna “indicador_aprendiz”.
O atributo “indicador_trabalho_intermitente” mostra se o registro é referente a modalidade de trabalho intermitente. Os possíveis valores são “0” ou “1”. 

SELECT 
  indicador_trabalho_intermitente,
  COUNT(*) AS QTD_INDICADOR_TRABALHO_INTERMITENTE
FROM `basedosdados-staging.br_me_caged_staging.microdados_antigos`
GROUP BY indicador_trabalho_intermitente
ORDER BY indicador_trabalho_intermitente ASC;

 
A acentuada quantidade de valores nulos se deve ao contexto dos dados. A modalidade de trabalho intermitente só foi aplicada a partir do ano de 2018. 
O atributo “indicador_trabalho_parcial” mostra se o registro é referente a modalidade de trabalho parcial. Os possíveis valores são “0” ou “1”. 
SELECT 
  indicador_trabalho_parcial,
  COUNT(*) AS QTD_INDICADOR_TRABALHO_PARCIAL
FROM `basedosdados-staging.br_me_caged_staging.microdados_antigos`
GROUP BY indicador_trabalho_parcial
ORDER BY indicador_trabalho_parcial ASC;

 
Da mesma forma do atributo anterior, a acentuada quantidade de valores nulos se deve ao contexto dos dados. Inclusive essas quantidades são iguais nos dois atributos. A modalidade de trabalho parcial só foi aplicada a partir do ano de 2018.

O atributo “indicador_portador_deficiencia” mostra se o registro é referente a um portador de deficiência ou não. Os possíveis valores são “0” ou “1” e qual outro valor será considera uma inconsistência.

SELECT 
  indicador_portador_deficiencia,
  COUNT(*) AS QTD_INDICADOR_PORTADOR_DEFICIENCIA
FROM `basedosdados-staging.br_me_caged_staging.microdados_antigos`
GROUP BY indicador_portador_deficiencia
ORDER BY indicador_portador_deficiencia ASC;

 
Nenhuma inconsistência foi verificada na coluna “indicador_portador_deficiencia”.
A coluna “grau_instrucao” tem como possíveis valores “01”, “02”, “03”, “04”, “05”, “06”, “07”, “08” ou “09” conforme as informações trazidas pelo dicionário de dados disponibilizado pela fonte de dados. Quaisquer valores diferentes desses serão considerados como inconsistências.
SELECT 
  grau_instrucao,
  COUNT(*) AS QTD_GRAU_INSTRUCAO
FROM `basedosdados-staging.br_me_caged_staging.microdados_antigos`
GROUP BY grau_instrucao
ORDER BY grau_instrucao ASC;

 
As inconsistências encontradas foram apenas em relação a valores nulos que serão classificados como “Não Informado” em etapas futuras.   
O atributo “idade” mostra os valores das idades das pessoas associadas a cada registro. A consulta irá verificar as inconsistências como valores nulos e valores que não sejam numéricos.

SELECT 
  idade,
  COUNT(*) AS QTD_IDADE
FROM `basedosdados-staging.br_me_caged_staging.microdados_antigos`
GROUP BY idade
ORDER BY idade ASC;

 

As inconsistências encontradas foram apenas em relação a valores com zeros a esquerda, pois a coluna “idade” ela é do tipo string. Para corrigir, a etapa de tratamento irá transformar a coluna para o tipo INT64 e, com isso, consertará essas inconsistências.

O atributo “sexo” mostra qual o gênero da pessoa referente àquele registro. Os possíveis valores são “0” ou “1” e qual outro valor será considera uma inconsistência.

SELECT 
  sexo,
  COUNT(*) AS QTD_SEXO
FROM `basedosdados-staging.br_me_caged_staging.microdados_antigos`
GROUP BY sexo
ORDER BY sexo ASC;

 

Nenhuma inconsistência foi verificada na coluna “sexo”.
O atributo “raca_cor” tem como possíveis valores “01”, “02”, “03”, “04”, “05”, “06”, “07”, “08”, “09” ou “99” conforme as informações trazidas pelo dicionário de dados disponibilizado pela fonte de dados. Quaisquer valores diferentes desses serão considerados como inconsistências.
SELECT 
  raca_cor,
  COUNT(*) AS QTD_RACA_COR
FROM `basedosdados-staging.br_me_caged_staging.microdados_antigos`
GROUP BY raca_cor
ORDER BY raca_cor ASC;

 

O último atributo a ser investigado é “subsetor_ibge” tem como possíveis valores numéricos entre “01” e “25” conforme as informações trazidas pelo dicionário de dados disponibilizado pela fonte de dados onde são caracterizados pelo seu setor econômico do registro em questão. Quaisquer valores diferentes desses serão considerados como inconsistências.
SELECT 
  subsetor_ibge,
  COUNT(*) AS QTD_SUBSETOR_IBGE
FROM `basedosdados-staging.br_me_caged_staging.microdados_antigos`
GROUP BY subsetor_ibge
ORDER BY subsetor_ibge ASC;

  
Algumas inconsistências foram encontradas. Os valores nulos que serão classificados como “Não Informado” em etapas futuras. Alguns valores distintos estão representando o mesmo valor (por exemplo “ 1” e “1”) e será feito um tratamento em etapas futuras para retirar o “espaço” dessa sobressalente desses valores.
O código apresentado a seguir é uma consulta que manipula dados da tabela no dataset da fonte de dados. A consulta possui várias etapas, que envolvem o tratamento e seleção dos dados de acordo com determinados critérios. Vamos analisar cada parte do código:
1.	A primeira parte utiliza a cláusula WITH para criar uma tabela temporária chamada "Tabela" com os seguintes campos:
•	Ano (ano de referência dos dados, convertido para INT64)
•	Estado (sigla da unidade federativa, convertido para STRING)
•	Movimentacao (tipo de movimentação desagregada, convertido para STRING)
•	Salario_Mensal (salário mensal, convertido para FLOAT64)
•	Aprendiz (indicador de aprendiz, convertido para STRING)
•	Trabalho_intermitente (indicador de trabalho intermitente, convertido para STRING)
•	Trabalho_Parcial (indicador de trabalho parcial, convertido para STRING)
•	PcD (indicador de portador de deficiência, convertido para STRING)
•	Escolaridade (grau de instrução, convertido para STRING)
•	Idade (idade do trabalhador, convertido para INT64)
•	Sexo (sexo do trabalhador, convertido para STRING)
•	Raca_Cor (raça/cor do trabalhador, convertido para STRING)
•	Subsetor (subsetor IBGE, convertido para INT64)
2.	Em seguida, a tabela "basedosdados-staging.br_me_caged_staging.microdados_antigos" é consultada e os dados são filtrados e transformados em tipos apropriados para cada campo, conforme descrito na primeira parte.

3.	O campo chamado "Escolaridade" é criado com base nos valores do campo "grau_instrucao". Esse campo é uma transformação dos valores de grau de instrução dos trabalhadores e segue as seguintes regras:
•	Se o valor de "grau_instrucao" for '01', '02', '03' ou '04', o valor de "Escolaridade" será '1' que representará o ensino fundamental incompleto.
•	Se o valor de "grau_instrucao" for '05' ou '06', o valor de "Escolaridade" será '2' que representará o ensino fundamental completo.
•	Se o valor de "grau_instrucao" for '07' ou '08', o valor de "Escolaridade" será '3' que representará o ensino médio completo.
•	Se o valor de "grau_instrucao" for '09', '10' ou '11', o valor de "Escolaridade" será '4' que representará o ensino superior completo.
•	Para qualquer outro valor de "grau_instrucao", o valor de "Escolaridade" será '99' que será interpretado como não informado.

4.	O atributo "subsetor" é criado fazendo o tratamento onde serão tirados todos os “espaços” dos valores da coluna. 
5.	A cláusula WHERE é utilizada para filtrar os dados da tabela "Tabela". Os registros são selecionados com base nos seguintes critérios:
•	O campo "Ano" deve estar em uma das opções '2019', '2018', '2017', '2016', '2015', '2014', '2013' ou '2012', pois será feita a análise a partir do ano de 2012.
•	O campo "Idade" não pode ser nenhum dos seguintes valores: '000', '0000000', '0000010', '0000011', '0000012', '0000013', '010', '011', '012', '013', '11', '13', pois a análise será feita a partir dos 14 anos de idade.
6.	Por fim, a consulta principal é feita, selecionando os seguintes campos da tabela "Tabela":
•	Ano, Estado, Movimentacao, Salario_Mensal, Aprendiz, Trabalho_Intermitente, Trabalho_Parcial, PcD, Escolaridade, Idade, Sexo, Raca_Cor.
•	O campo "Subsetor_Economico" é criado com base nos valores do campo "subsetor". Ele recebe valores de acordo com algumas condições onde serão agrupados os setores econômicos:
•	Se o valor de "subsetor" for menor ou igual a 13, o valor de "Subsetor_Economico" será '01'.
•	Se o valor de "subsetor" for igual a 14 ou estiver entre 18 e 23, o valor de "Subsetor_Economico" será '02'.
•	Se o valor de "subsetor" for igual a 15, o valor de "Subsetor_Economico" será '03'.
•	Se o valor de "subsetor" for igual a 16 ou igual a 17, o valor de "Subsetor_Economico" será '04'.
•	Se o valor de "subsetor" for igual a 24, o valor de "Subsetor_Economico" será '05'.
•	Se o valor de "subsetor" for igual a 25, o valor de "Subsetor_Economico" será '06'.
•	Para quaisquer outros valores de "subsetor", o valor de "Subsetor_Economico" será '99'.
7.	Um último filtro é aplicado na consulta final usando a cláusula WHERE. Os registros são selecionados com base nos seguintes critérios:
•	O campo "salario_mensal" deve estar entre 243 e 121500 (inclusive). Foram considerados 0,3 a 150 salários conforme a recomendação dos estudos do IPEA.
•	O campo "idade" deve ser maior ou igual a 14, pois a idade mínima para o trabalho formal é 14 anos como menor aprendiz.
A consulta final resulta em uma tabela com os campos mencionados, contendo dados filtrados e transformados de acordo com os critérios estabelecidos.

WITH Tabela AS (
  SELECT
SAFE_CAST(ano AS INT64) Ano,
SAFE_CAST(sigla_uf AS STRING) Estado,
SAFE_CAST(admitidos_desligados AS STRING) Movimentacao,
SAFE_CAST(salario_mensal AS FLOAT64) Salario_Mensal,
SAFE_CAST(indicador_aprendiz AS STRING) Aprendiz,
CASE
    WHEN SAFE_CAST(indicador_trabalho_intermitente AS STRING) = '1' THEN '1'
    WHEN SAFE_CAST(indicador_trabalho_intermitente AS STRING) = '0' THEN '0'
    ELSE '3'
END AS Trabalho_intermitente,
CASE
    WHEN SAFE_CAST(indicador_trabalho_parcial AS STRING) = '1' THEN '1'
    WHEN SAFE_CAST(indicador_trabalho_parcial AS STRING) = '0' THEN '0'
    ELSE '3'
END AS Trabalho_Parcial,
SAFE_CAST(indicador_portador_deficiencia AS STRING) PcD,
CASE
    WHEN SAFE_CAST(grau_instrucao AS STRING) = '01' OR SAFE_CAST(grau_instrucao AS STRING) = '02'OR SAFE_CAST(grau_instrucao AS STRING)= '03' OR SAFE_CAST(grau_instrucao AS STRING) = '04' THEN '1'
    WHEN SAFE_CAST(grau_instrucao AS STRING) = '05' OR SAFE_CAST(grau_instrucao AS STRING) = '06' THEN '2'
    WHEN SAFE_CAST(grau_instrucao AS STRING) = '07' OR SAFE_CAST(grau_instrucao AS STRING) = '08' THEN '3'
    WHEN SAFE_CAST(grau_instrucao AS STRING) = '09' OR SAFE_CAST(grau_instrucao AS STRING) = '10'OR SAFE_CAST(grau_instrucao AS STRING) = '11' THEN '4'
    ELSE '99'
END AS Escolaridade,
SAFE_CAST(idade AS INT64) Idade,
SAFE_CAST(sexo AS STRING) Sexo,
CASE 
    WHEN SAFE_CAST(raca_cor AS STRING) = '01' THEN '01'
    WHEN SAFE_CAST(raca_cor AS STRING) = '02' THEN '02'
    WHEN SAFE_CAST(raca_cor AS STRING) = '04' THEN '04'
    WHEN SAFE_CAST(raca_cor AS STRING) = '06' THEN '06'
    WHEN SAFE_CAST(raca_cor AS STRING) = '08' THEN '08'
    ELSE '99'
END AS Raca_Cor,
SAFE_CAST(REPLACE(subsetor_ibge, ' ', '') AS INT64) AS subsetor

from `basedosdados-staging.br_me_caged_staging.microdados_antigos`

WHERE Ano IN ('2019', '2018', '2017', '2016', '2015', '2014', '2013', '2012')
  AND idade NOT IN ('000', '0000000', '0000010', '0000011', '0000012', '0000013', '010', '011', '012', '013', '11', '13')     
)

SELECT Ano, Estado, Movimentacao, Salario_Mensal, Aprendiz, Trabalho_Intermitente, Trabalho_Parcial, PcD,
       Escolaridade, Idade, Sexo, Raca_Cor, 
       CASE 
          WHEN subsetor <= 13 THEN '01'
          WHEN subsetor = 14 OR subsetor >= 18 OR subsetor <= 23 THEN '02'
          WHEN subsetor = 15 THEN '03'
          WHEN subsetor = 16 OR subsetor = 17 THEN '04'
          WHEN subsetor = 24 THEN '05'
          WHEN subsetor = 25 THEN '06'
          ELSE '99'
       END AS Subsetor_Economico  

FROM Tabela

WHERE (salario_mensal <= 121500 AND salario_mensal >= 243 AND idade >= 14);

 
Essa consulta será utilizada em para fazer o download em um arquivo CSV através de uma função em python.
CAGED 2020 – 2023

A diferença desta tabela para aquela que foi tratada anteriormente está em alguns parâmetros que foram modificados pelo CAGED. Muitas das estratégias adotadas anteriormente serão idênticas a desta.
SELECT
  column_name,
  data_type,
  is_nullable
FROM
  `basedosdados.br_me_caged.INFORMATION_SCHEMA.COLUMNS`
WHERE
  table_name = 'microdados_movimentacao';

 
Para a análise foram escolhidos os seguintes atributos:
ano, sigla_uf, tipo_movimentacao, salario_mensal, indicador_aprendiz, indicador_trabalho_intermitente, indicador_trabalho_parcial, tipo_deficiencia, grau_instrucao, idade, sexo, raca_cor, cnae_2_secao.
A consulta a seguir irá verificar se o atributo “ano” possui alguma inconsistência como valores nulos, anos que não estão no formato correto (por exemplo, "202" em vez de "2020" ou "abc" em vez de um valor numérico), anos em formatos diferentes (como "2020" e "20" para o mesmo ano) ou anos que não estejam na cobertura temporal informada que seria de 2020 a 2023).
SELECT 
  ano AS Ano,
  COUNT(*) AS QTD
FROM ` basedosdados.br_me_caged.microdados_movimentacao`
GROUP BY Ano
ORDER BY Ano ASC;
 


A consulta abaixo irá verificar se o atributo “sigla_uf” possui alguma inconsistência como por exemplo(“ ”) e seleciona a sigla do estado (sigla_uf) e a contagem de registros (QTD) da tabela. Em seguida, agrupa os resultados por sigla do estado e ordena os resultados pela sigla do estado em ordem ascendente (ASC), ou seja, conta o número de registros em cada estado e exibe os resultados em ordem alfabética.

SELECT 
  sigla_uf,
  COUNT(*) AS QTD
FROM ` basedosdados.br_me_caged.microdados_movimentacao`
GROUP BY sigla_uf
ORDER BY sigla_uf ASC;
 

Esta consulta verifica se o atributo “tipo_movimentacao” possui alguma inconsistência como valores nulos, valores numéricos em formatos incorretos e seleciona o tipo de movimentação e a contagem de registros (QTD) da tabela, agrupa os resultados por tipo de movimentação e ordena os resultados pelo tipo de movimentação em ordem ascendente (ASC). Em outras palavras, a consulta conta o número de registros de cada tipo de movimentação e exibe os resultados em ordem alfabética.
SELECT 
  tipo_movimentacao,
  COUNT(*) AS QTD
FROM `basedosdados.br_me_caged.microdados_movimentacao`
GROUP BY tipo_movimentacao
ORDER BY tipo_movimentacao ASC;

 

A consulta verifica se o atributo “salario_mensal” possui alguma inconsistência como valores nulos, valores numéricos em formatos incorretos e seleciona a coluna salario_mensal e a contagem de registros (QTD) da tabela em seguida, agrupa os resultados por salário mensal e ordena os resultados pelo salário mensal em ordem ascendente (ASC). Em outras palavras, a consulta conta o número de registros em cada faixa de salário mensal e exibe os resultados em ordem crescente.

SELECT 
  salario_mensal,
  COUNT(*) AS QTD
FROM `basedosdados.br_me_caged.microdados_movimentacao`
GROUP BY salario_mensal
ORDER BY salario_mensal ASC;

 

Esta consulta verifica se há inconsistências e seleciona a coluna indicador_aprendiz e a contagem de registros (QTD) da tabela, agrupa os resultados por indicador_aprendiz e ordena os resultados por indicador_aprendiz em ordem ascendente (ASC) ou seja exibe os resultados em ordem crescente.
SELECT 
  indicador_aprendiz,
  COUNT(*) AS QTD
FROM `basedosdados.br_me_caged.microdados_movimentacao`
GROUP BY indicador_aprendiz
ORDER BY indicador_aprendiz ASC;

 


A consulta verifica se há inconsistências nas colunas como valores nulos, números que não estão formatados corretamente, seleciona a coluna indicador_trabalho_intermitente e a contagem de registros (QTD) da tabela. Em seguida, agrupa os resultados por indicador_trabalho_intermitente e ordena os resultados por indicador_trabalho_intermitente em ordem ascendente (ASC) e exibe os resultados em ordem crescente.
SELECT 
  indicador_trabalho_intermitente,
  COUNT(*) AS QTD
FROM `basedosdados.br_me_caged.microdados_movimentacao`
GROUP BY indicador_trabalho_intermitente
ORDER BY indicador_trabalho_intermitente ASC;

 



Esta consulta verifica se há algumas inconsistências e visa contar a quantidade de ocorrências para cada valor único da coluna indicador_trabalho_parcial. Os resultados são agrupados de acordo com os valores dessa coluna e ordenados de forma ascendente.


SELECT 
  indicador_trabalho_parcial,
  COUNT(*) AS QTD
FROM `basedosdados.br_me_caged.microdados_movimentacao`
GROUP BY indicador_trabalho_parcial
ORDER BY indicador_trabalho_parcial ASC;

 


Essa consulta foi criada para verificar se há inconsistências e determinar a frequência com que cada tipo de deficiência aparece na coluna "tipo_deficiencia". Os resultados são organizados agrupando as ocorrências por tipo de deficiência e, em seguida, organizados em ordem alfabética crescente.

SELECT 
  tipo_deficiencia,
  COUNT(*) AS QTD
FROM `basedosdados.br_me_caged.microdados_movimentacao`
GROUP BY tipo_deficiencia
ORDER BY tipo_deficiencia ASC;

 




A finalidade dessa consulta é determinar a quantidade de ocorrências para cada nível de educação registrado na coluna "grau_instrucao". Os resultados são organizados em grupos de acordo com os diversos níveis de educação e, posteriormente, são dispostos em ordem alfabética crescente.


SELECT 
  grau_instrucao,
  COUNT(*) AS QTD
FROM `basedosdados.br_me_caged.microdados_movimentacao`
GROUP BY grau_instrucao
ORDER BY grau_instrucao ASC;

 

O propósito dessa consulta é contabilizar quantas vezes cada idade aparece na coluna "idade". Os resultados são organizados em grupos de acordo com as várias idades presentes e, em seguida, são dispostos em ordem crescente com base nas idades.

SELECT 
  idade,
  COUNT(*) AS QTD
FROM `basedosdados.br_me_caged.microdados_movimentacao`
GROUP BY idade
ORDER BY idade ASC;

 

Essa consulta busca determinar a quantidade de ocorrências para cada categoria de sexo registrada na coluna "sexo". Os resultados são organizados em grupos com base nos diferentes valores de sexo e, posteriormente, são arranjados em ordem alfabética crescente.

SELECT 
  sexo,
  COUNT(*) AS QTD
FROM `basedosdados.br_me_caged.microdados_movimentacao`
GROUP BY sexo
ORDER BY sexo ASC;

 





O objetivo é contar quantas vezes cada categoria de raça/cor é registrada na coluna "raca_cor". Os resultados são agrupados de acordo com as diferentes categorias de raça/cor e ordenados em ordem alfabética crescente.



SELECT 
  raca_cor,
  COUNT(*) AS QTD
FROM `basedosdados.br_me_caged.microdados_movimentacao`
GROUP BY raca_cor
ORDER BY raca_cor ASC;

 




Essa consulta SQL busca determinar quantas vezes cada setor econômico da Classificação Nacional de Atividades Econômicas (CNAE) de 2ª seção é mencionado na coluna "cnae_2_secao". Os resultados são agrupados com base nas diferentes categorias da CNAE de 2ª seção e organizados em ordem crescente de cnae_2_secao.

SELECT 
  cnae_2_secao,
  COUNT(*) AS QTD
FROM `basedosdados.br_me_caged.microdados_movimentacao`
GROUP BY cnae_2_secao
ORDER BY cnae_2_secao ASC;

 

TRATAMENTO CAGED 2020-2023


O código abaixo cria uma tabela temporária fazendo a tipagem para cada coluna. Os dados selecionados são transformados e categorizados de acordo com várias regras. O código organiza os dados por ano, estado, tipo de movimentação, salário mensal, indicadores de aprendiz e trabalho intermitente, entre outros. Além disso, as informações sobre deficiência, escolaridade, idade, sexo, raça/cor e setor econômico são categorizadas em diferentes classes conforme as especificações.
O código também faz algumas transformações nos dados da tabela original. Por exemplo, ele converte as colunas tipo_movimentacao e cnae_2_secao para string e as colunas salario_mensal para float64 e idade para int64. Ele também usa o CASE para converter os valores das colunas indicador_aprendiz, indicador_trabalho_intermitente, indicador_trabalho_parcial, tipo_deficiencia, grau_instrucao, sexo, raca_cor e cnae_2_secao para números mais gerenciáveis. Ele filtra os dados de acordo com várias condições. Selecionar os dados de ano, estado, movimentação, salario mensal, aprendiz, trabalho intermitente, trabalho parcial, Pcd, escolaridade, idade, sexo, raça/cor e subsetor econômico da tabela . Filtra os resultados para incluir somente as linhas em que o salário mensal está entre 350 e 172950, a idade é amiof ou igual a 14, o trabalho intermitente não é igual a 9 e o trabalho parcial não é igual a 9.

WITH Tabela AS (
  SELECT
SAFE_CAST(ano AS INT64) Ano,
SAFE_CAST(sigla_uf AS STRING) Estado,
CASE 
    WHEN SAFE_CAST(tipo_movimentacao AS STRING) = '10' OR SAFE_CAST(tipo_movimentacao AS STRING)= '20' OR SAFE_CAST(tipo_movimentacao AS STRING) = '25'
      OR SAFE_CAST(tipo_movimentacao AS STRING) = '35' OR SAFE_CAST(tipo_movimentacao AS STRING) = '70' OR SAFE_CAST(tipo_movimentacao AS STRING) = '97' THEN '01'
    WHEN SAFE_CAST(tipo_movimentacao AS STRING) = '31' OR SAFE_CAST(tipo_movimentacao AS STRING) = '32' OR SAFE_CAST(tipo_movimentacao AS STRING) = '33'
      OR SAFE_CAST(tipo_movimentacao AS STRING) = '40' OR SAFE_CAST(tipo_movimentacao AS STRING) = '43' OR SAFE_CAST(tipo_movimentacao AS STRING) = '45'
      OR SAFE_CAST(tipo_movimentacao AS STRING) = '50' OR SAFE_CAST(tipo_movimentacao AS STRING) = '60' OR SAFE_CAST(tipo_movimentacao AS STRING)= '80'
      OR SAFE_CAST(tipo_movimentacao AS STRING) = '90' OR SAFE_CAST(tipo_movimentacao AS STRING) = '98' THEN '02'
    ELSE '99'
END AS Movimentacao, 
SAFE_CAST(salario_mensal AS FLOAT64) Salario_Mensal,
SAFE_CAST(indicador_aprendiz AS STRING) Aprendiz,
SAFE_CAST(indicador_trabalho_intermitente AS STRING) AS Trabalho_Intermitente,
SAFE_CAST(indicador_trabalho_parcial AS STRING) AS Trabalho_Parcial,
CASE 
    WHEN SAFE_CAST(tipo_deficiencia AS STRING) = '0' THEN '0'
    ELSE '1'
END AS PcD,
CASE
    WHEN SAFE_CAST(grau_instrucao AS STRING) = '1' OR SAFE_CAST(grau_instrucao AS STRING) = '2'OR SAFE_CAST(grau_instrucao AS STRING)= '3' 
      OR SAFE_CAST(grau_instrucao AS STRING) = '4' THEN '1'
    WHEN SAFE_CAST(grau_instrucao AS STRING) = '5' OR SAFE_CAST(grau_instrucao AS STRING) = '6' THEN '2'
    WHEN SAFE_CAST(grau_instrucao AS STRING) = '7' OR SAFE_CAST(grau_instrucao AS STRING) = '8' THEN '3'
    WHEN SAFE_CAST(grau_instrucao AS STRING) = '9' OR SAFE_CAST(grau_instrucao AS STRING) = '10'OR SAFE_CAST(grau_instrucao AS STRING) = '11' 
      OR SAFE_CAST(grau_instrucao AS STRING) = '80'THEN '4'
    ELSE '99'
END AS Escolaridade,
SAFE_CAST(idade AS INT64) Idade,
CASE 
    WHEN SAFE_CAST(sexo AS STRING) = '1' THEN '01'
    ELSE '02'
END AS Sexo,
CASE 
    WHEN SAFE_CAST(raca_cor AS STRING) = '5' THEN '01' #Indígena
    WHEN SAFE_CAST(raca_cor AS STRING) = '1' THEN '02' #Branco
    WHEN SAFE_CAST(raca_cor AS STRING) = '2' THEN '04' #Preto
    WHEN SAFE_CAST(raca_cor AS STRING) = '4' THEN '06' #Amarelo
    WHEN SAFE_CAST(raca_cor AS STRING) = '3' THEN '08' #Pardo
    ELSE '99'                                          #Não Informado
END AS Raca_Cor,
CASE 
          WHEN SAFE_CAST(cnae_2_secao AS STRING) = 'B' OR cnae_2_secao = 'C' THEN '01' #Indústria
          WHEN SAFE_CAST(cnae_2_secao AS STRING) = 'F' THEN '03' #Construção Civil
          WHEN SAFE_CAST(cnae_2_secao AS STRING)= 'G' THEN '04' #Comércio
          WHEN SAFE_CAST(cnae_2_secao AS STRING) = 'O' THEN '05' #Adm Pública
          WHEN SAFE_CAST(cnae_2_secao AS STRING) = 'A' THEN '06' #Agropecuária
          ELSE '02' #Serviço
END AS Subsetor_Economico,  

FROM `basedosdados.br_me_caged.microdados_movimentacao` 

)

SELECT Ano, Estado, Movimentacao, Salario_Mensal, Aprendiz, Trabalho_Intermitente, Trabalho_Parcial, PcD,
       Escolaridade, Idade, Sexo, Raca_Cor,Subsetor_Economico,

FROM Tabela

WHERE (Salario_Mensal <= 172950 AND Salario_Mensal >= 350 AND Idade >= 14 AND Trabalho_Intermitente != '9' AND Trabalho_Parcial != '9');

 



A consulta  seleciona o tipo de movimento e a contagem de registros (qtd) da tabela . Em seguida, agrupa os resultados por tipo de movimento e ordena os resultados pelo número de registros (qtd) em ordem decrescente (DESC), ou seja a consulta conta o número de registros de cada tipo de movimento e exibe os resultados em ordem decrescente

SELECT
   tipo_movimentacao,
   Count(*) AS qtd
FROM
    `basedosdados.br_me_caged.microdados_movimentacao` 
GROUP BY
    tipo_movimentacao
ORDER BY
    qtd DESC;
Select * 
FROM
    `basedosdados.br_me_caged.microdados_movimentacao` 


 





 
CENSO 2010
A consulta sobre o atributo “sigla_uf” tem por objetivo verificar inconsistências como verificar valores duplicados, ou seja, verificar se existem estados com a mesma sigla (mesmo estado escrito de forma diferente ou com diferentes grafias), verificar valores em branco, contabilizando todos os valores nulos que a coluna possui.
SELECT 
  sigla_uf AS Estado,
  COUNT(*) AS QTD
FROM `basedosdados.br_ibge_censo_demografico.microdados_pessoa_2010`
GROUP BY Estado
ORDER BY Estado ASC

 

O atributo “v0601” está relacionado ao sexo da pessoa daquele registro. Segundo o dicionário do banco de dados eles podem assumir os valores “1” ou “2” e a consulta seguir irá verificar se possui valores em branco ou algum valor diferente daqueles determinados no dicionário.
SELECT 
  v0601 AS Sexo,
  COUNT(*) AS QTD
FROM `basedosdados.br_ibge_censo_demografico.microdados_pessoa_2010`
GROUP BY Sexo
ORDER BY Sexo ASC

 

O atributo “v6036” está relacionado à idade da pessoa daquele registro. A consulta feita irá verificar se possui valores em branco e valores que não sejam numéricos.
SELECT 
  v6036 AS Idade,
  COUNT(*) AS QTD
FROM `basedosdados.br_ibge_censo_demografico.microdados_pessoa_2010`
GROUP BY Idade
ORDER BY Idade ASC
 

O atributo “v0606” está relacionado à raça ou cor da pessoa daquele registro. Segundo o dicionário do banco de dados eles podem assumir os valores “1”, “2”, “3”, “4”, “5” ou “9” e a consulta seguir irá verificar se possui valores em branco ou algum valor diferente daqueles determinados no dicionário.
SELECT 
  v0606 AS Raca_Cor,
  COUNT(*) AS QTD
FROM `basedosdados.br_ibge_censo_demografico.microdados_pessoa_2010`
GROUP BY Raca_Cor
ORDER BY Raca_Cor ASC

 

O atributo “v6400” está relacionado à escolaridade da pessoa daquele registro. Segundo o dicionário do banco de dados eles podem assumir os valores “1”, “2”, “3”, “4” ou “5” e a consulta seguir irá verificar se possui valores em branco ou algum valor diferente daqueles determinados no dicionário.
SELECT 
  v6400 AS Escolaridade,
  COUNT(*) AS QTD
FROM `basedosdados.br_ibge_censo_demografico.microdados_pessoa_2010`
GROUP BY Escolaridade
ORDER BY Escolaridade ASC

 

Os atributos “v0614”, “v0615” e “v0616”” estão relacionados, respectivamente, à deficiência visual, deficiência auditiva e deficiência física da pessoa daquele registro. Segundo o dicionário do banco de dados eles podem assumir os valores “1”, “2”, “3”, “4” ou “9” e as consultas seguir irá verificar se possui valores em branco ou algum valor diferente daqueles determinados no dicionário.

SELECT 
  v0614 AS DefVisual,
  COUNT(*) AS QTD
FROM `basedosdados.br_ibge_censo_demografico.microdados_pessoa_2010`
GROUP BY DefVisual
ORDER BY DefVisual ASC

 

SELECT 
  v0615 AS DefAuditivo,
  COUNT(*) AS QTD
FROM `basedosdados.br_ibge_censo_demografico.microdados_pessoa_2010`
GROUP BY DefAuditivo
ORDER BY DefAuditivo ASC

 

SELECT 
  v0616 AS DefFisica,
  COUNT(*) AS QTD
FROM `basedosdados.br_ibge_censo_demografico.microdados_pessoa_2010`
GROUP BY DefFisica
ORDER BY DefFisica ASC

 

O atributo “v0617” está relacionado à deficiência intelectual da pessoa daquele registro. Segundo o dicionário do banco de dados eles podem assumir os valores “1”, “2” ou “9” e a consulta seguir irá verificar se possui valores em branco ou algum valor diferente daqueles determinados no dicionário.
SELECT 
  v0617 AS DefIntelectual,
  COUNT(*) AS QTD
FROM `basedosdados.br_ibge_censo_demografico.microdados_pessoa_2010`
GROUP BY DefIntelectual
ORDER BY DefIntelectual ASC

 
A consulta a seguir consiste em definir uma tabela temporária para transformar as colunas da tabela original em formatos mais legíveis usando a cláusula "SAFE_CAST" para evitar erros de tipo de dados.
A coluna "Estado" é criada a partir da coluna "sigla_uf" da tabela original e recebe o alias "Estado".
A coluna "Sexo" é criada a partir da coluna "V0601" da tabela original. Se o valor for '1', é considerado "Masculino" (código '01'), caso contrário, é considerado "Feminino" (código '02').
A coluna "Raca_Cor" é criada a partir da coluna "V0606" da tabela original. Os valores numéricos são mapeados para códigos de acordo com a seguinte correspondência para se adequar ao padrão adotado nas outras tabelas: ‘1’ é "Branco" (código '02'), ‘2’ é "Preto" (código '04'), ‘3’ é "Amarelo" (código '06'), ‘4’ é "Pardo" (código '08'), ‘5’ é "Indígena" (código '01') e qualquer outro valor é considerado como "Não Informado" (código '99').
A coluna "Idade" é criada a partir da coluna "V6036" da tabela original. O tipo é convertido para INT64 por se tratar de um atributo numérico.
A coluna "Escolaridade" é criada a partir da coluna "V6400" da tabela original, mantendo o mesmo formato.
A coluna "PcD" é criada a partir das colunas "V0614", "V0615", "V0616" e "V0617" da tabela original. Se alguma das colunas "V0614", "V0615", "V0616" tiver um valor '1', indicando uma dificuldade permanente ou tiver um valor ‘2’ indicando grandes dificuldade ou se a coluna "V0617" tiver valor ‘1’, indicando deficiência mental/intelectual permanente, é considerado como "Sim" (código '1') para portador de deficiência, caso contrário, é considerado como "Não" (código '0') para portador de deficiência.
A consulta final seleciona todas as colunas da tabela temporária e filtra os registros onde a idade (coluna "Idade") está entre 14 e 121 anos. Foi escolhida essa faixa etária, pois a idade mínima para ingressar no mercado de trabalho formal é com 14 anos como aprendiz e a idade máxima já registrada de um brasileiro foi de 121 anos.
WITH
  Tabela AS (
  SELECT
    SAFE_CAST(sigla_uf AS STRING) Estado,
    CASE
      WHEN SAFE_CAST(V0601 AS STRING) = '1' THEN '01'#Masculino
    ELSE
    '02'#Feminino
  END
    AS Sexo,
    CASE
      WHEN SAFE_CAST(v0606 AS STRING) = '1' THEN '02' #'Branco'
      WHEN SAFE_CAST(v0606 AS STRING) = '2' THEN '04' #'Preto'
      WHEN SAFE_CAST(v0606 AS STRING) = '3' THEN '06' #'Amarelo'
      WHEN SAFE_CAST(v0606 AS STRING) = '4' THEN '08' #'Pardo'
      WHEN SAFE_CAST(v0606 AS STRING) = '5' THEN '01' #'Indígena'
    ELSE
    '99' #Não Informado
  END
    AS Raca_Cor,
    SAFE_CAST(v6036 AS INT64) Idade,
    SAFE_CAST(v6400 AS STRING) Escolaridade,
    CASE
      WHEN SAFE_CAST(v0614 AS STRING) = '1'OR SAFE_CAST(v0614 AS STRING) = '2' OR SAFE_CAST(v0615 AS STRING) = '1'OR SAFE_CAST(v0615 AS STRING) = '2' OR SAFE_CAST(v0616 AS STRING) = '1'OR SAFE_CAST(v0616 AS STRING) = '2' OR SAFE_CAST(v0617 AS STRING) = '1' THEN '1'#Sim
    ELSE
    '0' #Não
  END
    AS PcD,
  FROM
    `basedosdados.br_ibge_censo_demografico.microdados_pessoa_2010`)
SELECT
  *
FROM
  Tabela
WHERE
  Idade >= 14
  AND Idade <= 121;

 
Uma tabela temporária é definida para transformar as colunas da tabela original em formatos mais legíveis usando a cláusula "SAFE_CAST" para evitar erros de tipo de dados.
A query a seguir cria uma nova tabela com informações mais legíveis e categorizadas, a partir dos dados da tabela censo2010. Os campos Estado, Sexo, Raca_Cor, Idade, Escolaridade e PcD foram convertidos ou categorizados para facilitar a análise e o uso dessas informações.
Coluna Original	Tipo Original	Categorização
Estado	STRING	STRING (Sigla dos estados)
Sexo	STRING	Masculino / Feminino
Raca_Cor	STRING	Branco / Preto / Amarelo / Pardo / Indígena / Não Informado
Idade	INT64	INT64 (idade)
Escolaridade	STRING	Fundamental Incompleto / Fundamental Completo / Médio Completo / Superior Completo / Não Informado
PcD	STRING	Sim / Não / Não Informado

CREATE TABLE
  `symphone-project.projeto_final.censo2010-final` AS
SELECT
  SAFE_CAST(Estado AS STRING) Estado,
  CASE
    WHEN SAFE_CAST(Sexo AS STRING) = '1' THEN 'Masculino'
  ELSE
  'Feminino'
END
  AS Sexo,
  CASE
    WHEN SAFE_CAST(Raca_Cor AS STRING) = '2' THEN 'Branco'
    WHEN SAFE_CAST(Raca_Cor AS STRING) = '4' THEN 'Preto'
    WHEN SAFE_CAST(Raca_Cor AS STRING) = '6' THEN 'Amarelo'
    WHEN SAFE_CAST(Raca_Cor AS STRING) = '8' THEN 'Pardo'
    WHEN SAFE_CAST(Raca_Cor AS STRING) = '1' THEN 'Indígena'
  ELSE
  'Não Informado'
END
  AS Raca_Cor,
  SAFE_CAST(Idade AS INT64) Idade,
  CASE
    WHEN SAFE_CAST(Escolaridade AS STRING) = '1' THEN 'Fundamental Incompleto'
    WHEN SAFE_CAST(Escolaridade AS STRING) = '2' THEN 'Fundamental Completo'
    WHEN SAFE_CAST(Escolaridade AS STRING) = '3' THEN 'Médio Completo'
    WHEN SAFE_CAST(Escolaridade AS STRING) = '4' THEN 'Superior Completo'
  ELSE
  'Não Informado'
END
  AS Escolaridade,
  CASE
    WHEN SAFE_CAST(PcD AS STRING) = '1' THEN 'Sim'
    WHEN SAFE_CAST(PcD AS STRING) = '0' THEN 'Não'
  ELSE
  'Não Informado'
END
  AS PcD
FROM
  `symphone-project.projeto_final.censo2010`

 

Unindo Tabelas: CAGED (2012 - 2019) e CAGED (2020 - 2023)

CAGED (2012 – 2023)

Após as etapas de transformação e mineração de dados realizadas tanto na tabela CAGED (2012-2019) quanto na tabela CAGED (2020 - 2023) iremos realizar a união das duas tabelas, já que o processo foi realizado separadamente devido a grande quantidade de dados contidos antes da mineração. 

A instrução CREATE TABLE foi usada para criar uma nova tabela chamada caged-total no projeto `projeto_final`. Essa instrução é frequentemente usada para definir a estrutura de uma nova tabela.

A cláusula UNION ALL é usada para combinar todas as linhas das duas tabelas, incluindo duplicatas (se houver) e sem remover os registros duplicados. Portanto, o resultado final na tabela caged-total conterá todas as linhas das tabelas caged-2012-2019 e caged-2020-2023. O schema das tabelas foi elaborado e verificado anteriormente a fim de manter compatibilidade de atributos entre as duas tabelas.

CREATE TABLE `symphone-project.projeto_final.caged-total` AS

SELECT * FROM `symphone-project.projeto_final.caged-2012-2019`
UNION ALL
SELECT * FROM  `symphone-project.projeto_final.caged-2020-2023`


 



Realizando consulta para visualizar os dados da tabela criada:

SELECT * FROM `symphone-project.projeto_final.caged-total`

 

Podemos visualizar com essa amostra de dados, que muitos dados estão em forma numérica, o que foi corrigido na parte de “Tradução da tabela”,  apresentada abaixo.


Tradução da Tabela CAGED Total

Foi realizada a criação de uma nova tabela nomeada `caged-total-final` no projeto `projeto_final`, dentro do ambiente do BigQuery. A nova tabela é derivada da transformação dos dados da tabela `caged-total`, a transformação envolve a conversão de alguns campos para formatos mais legíveis, como substituir dados numéricos por dados descritivos, como "Admissão" ou "Desligamento", e categorizar informações, como raça, escolaridade, e etc.

●	CREATE TABLE cria uma nova tabela  no `projeto_final` 
●	SELECT ... FROM seleciona as colunas da tabela `caged-total`
●	A função SAFE_CAST foi usada para converter os valores dessas colunas para tipos de dados específicos (como INT64, FLOAT64 ou STRING), e em seguida, aplica a lógica de transformação usando a cláusula CASE para tornar os dados mais compreensíveis. Por exemplo, a coluna Movimentacao é convertida para valores como "Admissão", "Desligamento" ou "Não Informado" com base no valor numérico original.
●	END AS, usado para encerrar a cláusula CASE






CREATE TABLE `symphone-project.projeto_final.caged-total-final` AS
SELECT
SAFE_CAST(Ano AS INT64) Ano,
SAFE_CAST(Estado AS STRING) Estado,
CASE
    WHEN SAFE_CAST(Movimentacao AS STRING) = '1' THEN 'Admissão'
    WHEN SAFE_CAST(Movimentacao AS STRING) = '2' THEN 'Desligamento'
    ELSE 'Não Informado'
END AS Movimentacao,
SAFE_CAST(Salario_Mensal AS FLOAT64) Salario_Mensal,
CASE
    WHEN SAFE_CAST(Aprendiz AS STRING) = '1' THEN 'Sim'
    WHEN SAFE_CAST(Aprendiz AS STRING) = '0' THEN 'Não'
    ELSE 'Não Informado'
END AS Aprendiz,
CASE
    WHEN SAFE_CAST(Trabalho_Intermitente AS STRING) = '1' THEN 'Sim'
    WHEN SAFE_CAST(Trabalho_Intermitente AS STRING) = '0' THEN 'Não'
    ELSE 'Não se Aplica'
END AS Trabalho_Intermitente,
CASE
    WHEN SAFE_CAST(Trabalho_Parcial AS STRING) = '1' THEN 'Sim'
    WHEN SAFE_CAST(Trabalho_Parcial AS STRING) = '0' THEN 'Não'
    ELSE 'Não se Aplica'
END AS Trabalho_Parcial,
CASE
    WHEN SAFE_CAST(PcD AS STRING) = '1' THEN 'Sim'
    WHEN SAFE_CAST(PcD AS STRING) = '0' THEN 'Não'
    ELSE 'Não Informado'
END AS  PcD,
CASE
          WHEN SAFE_CAST(Escolaridade AS STRING) = '1' THEN 'Fundamental Incompleto'
          WHEN SAFE_CAST(Escolaridade AS STRING) = '2' THEN 'Fundamental Completo'
          WHEN SAFE_CAST(Escolaridade AS STRING) = '3' THEN 'Médio Completo'
          WHEN SAFE_CAST(Escolaridade AS STRING) = '4' THEN 'Superior Completo'
          ELSE 'Não Informado'
END AS  Escolaridade,
SAFE_CAST(Idade AS INT64) Idade,
CASE
          WHEN SAFE_CAST(Sexo AS STRING) = '1' THEN 'Masculino'
          ELSE 'Feminino'
END AS Sexo,
CASE
          WHEN SAFE_CAST(Raca_Cor AS STRING) = '2' THEN 'Branco'
          WHEN SAFE_CAST(Raca_Cor AS STRING) = '4' THEN 'Preto'
          WHEN SAFE_CAST(Raca_Cor AS STRING) = '6' THEN 'Amarelo'
          WHEN SAFE_CAST(Raca_Cor AS STRING) = '8' THEN 'Pardo'
          WHEN SAFE_CAST(Raca_Cor AS STRING) = '1' THEN 'Indígena'
          ELSE 'Não Informado'
END AS Raca_Cor,
CASE
          WHEN SAFE_CAST(Subsetor_Economico AS STRING) = '1' THEN 'Indústria'
          WHEN SAFE_CAST(Subsetor_Economico AS STRING) = '2' THEN 'Serviço'
          WHEN SAFE_CAST(Subsetor_Economico AS STRING) = '3' THEN 'Construção Civil'
          WHEN SAFE_CAST(Subsetor_Economico AS STRING) = '4' THEN 'Comércio'
          WHEN SAFE_CAST(Subsetor_Economico AS STRING) = '5' THEN 'Adm. Pública'
          WHEN SAFE_CAST(Subsetor_Economico AS STRING) = '6' THEN 'Agropecuária'
          ELSE 'Não Informado'
END AS Subsetor_Economico

FROM `symphone-project.projeto_final.caged-total`;

 

Realizando consulta para visualizar os dados da tabela criada:

SELECT * FROM `symphone-project.projeto_final.caged-total-final`

 

A nova tabela`caged-total-final` contém os mesmos dados da tabela original `caged-total`, mas com alguns campos transformados para tornar as informações mais claras e significativas. Isso pode facilitar análises e a apresentação desses dados no relatório, parte da visualização.






Consultas Colunas PNADC
Estaremos utilizando SQL para interagir com um banco de dados que contém dados da Pesquisa Nacional por Amostra de Domicílios Contínua (PNADC) do Instituto Brasileiro de Geografia e Estatística (IBGE).

Essa consulta vai selecionar todas as colunas da tabela microdados na base de dados basedosdados.br_ibge_pnadc  e retornar no máximo 1000 linhas de resultados.
SELECT * FROM `basedosdados.br_ibge_pnadc.microdados` LIMIT 1000 ;

 
A consulta retorna um conjunto de resultados contendo informações sobre as colunas da tabela 'microdados', incluindo seus nomes, tipos de dados e se elas permitem valores nulos ou não. Isso é útil para entender a estrutura da tabela e como os dados estão organizados nela.

SELECT
  column_name,
  data_type,
  is_nullable
FROM
  `basedosdados.br_ibge_pnadc.INFORMATION_SCHEMA.COLUMNS`
WHERE
  table_name = 'microdados';
 

Essa consulta vai fornecer um conjunto de resultados que mostra a quantidade total de registros para cada ano na base de dados da PNADC do IBGE, ordenados de forma ascendente pelos ano.
SELECT
  ano,
  COUNT(*) as QTD
FROM `basedosdados.br_ibge_pnadc.microdados`
GROUP BY ano
ORDER BY ano;
 
As próximas consultas seguirão mesmo padrão, irão nos retornar resultados segundo os registros solicitados que constam na base de dados PNADC do IBGE.
SELECT
  sigla_uf,
  COUNT(*) as QTD
FROM `basedosdados.br_ibge_pnadc.microdados`
GROUP BY sigla_uf
ORDER BY sigla_uf;

 
SELECT
  V2007 AS sexo,
  COUNT(*) as QTD
FROM `basedosdados.br_ibge_pnadc.microdados`
GROUP BY V2007
ORDER BY V2007;

 
SELECT
  V2010 AS raca_cor,
  COUNT(*) as QTD
FROM `basedosdados.br_ibge_pnadc.microdados`
GROUP BY V2010
ORDER BY V2010;

 




SELECT
  V2009 AS idade,
  COUNT(*) as QTD
FROM `basedosdados.br_ibge_pnadc.microdados`
GROUP BY V2009
ORDER BY V2009;

 
SELECT
  VD3004 AS grau_instrucao,
  COUNT(*) as QTD
FROM `basedosdados.br_ibge_pnadc.microdados`
GROUP BY VD3004
ORDER BY VD3004;

 

TRATAMENTO PNADC
Essa consulta realiza uma série de transformações em uma tabela chamada "Tabela" e, em seguida, seleciona as linhas que correspondem a determinados critérios de idade.
Vou explicar o que cada parte do código faz:
WITH Tabela AS (...): Nesta parte, estamos criando uma tabela temporária chamada "Tabela" por meio de um comando CTE. Isso envolve selecionar várias colunas da tabela basedosdados.br_ibge_pnadc.microdados e realizar algumas transformações nos dados. Convertemos as colunas para os tipos de dados corretos, como INT64 e STRING, e também mapeando valores de diferentes colunas para novos valores (como mapear códigos de raça/etnia para categorias específicas). Essa parte do código está essencialmente preparando os dados para a análise subsequente.
SELECT * FROM Tabela WHERE Idade >= 14 AND Idade <= 121;: Nesta parte, estamos selecionando todas as colunas da tabela "Tabela" que foi definida anteriormente. Estamos aplicando um filtro usando a cláusula WHERE para selecionar apenas as linhas em que a coluna "Idade" está dentro do intervalo de 14 a 121 anos. Utilizado para excluir registros com idades inválidas ou irrelevantes para a análise.

WITH Tabela AS (
      SELECT  
        SAFE_CAST(ano AS INT64) Ano, 
        SAFE_CAST(sigla_uf AS STRING) Estado, 
        CASE 
          WHEN SAFE_CAST(V2007 AS STRING) = '1' THEN '01'
          ELSE '02'
        END AS Sexo, 
        CASE 
          WHEN SAFE_CAST(V2010 AS STRING) = '1' THEN '02' #'Branco' 
          WHEN SAFE_CAST(V2010 AS STRING) = '2' THEN '04' #'Preto'
          WHEN SAFE_CAST(V2010 AS STRING) = '3' THEN '06' #'Amarelo'
          WHEN SAFE_CAST(V2010 AS STRING) = '4' THEN '08' #'Pardo'
          WHEN SAFE_CAST(V2010 AS STRING) = '5' THEN '01' #'Indígena'
          ELSE '99'                                       #Não Informado
        END AS Raca_Cor, 
        SAFE_CAST(V2009 AS INT64) AS Idade,

        CASE
          WHEN SAFE_CAST(VD3004 AS STRING) = '1' OR SAFE_CAST(VD3004 AS STRING) = '2' THEN '1'
          WHEN SAFE_CAST(VD3004 AS STRING) = '3' OR SAFE_CAST(VD3004 AS STRING) = '4' THEN '2'
          WHEN SAFE_CAST(VD3004 AS STRING) = '5' OR SAFE_CAST(VD3004 AS STRING) = '6' THEN '3'
          WHEN SAFE_CAST(VD3004 AS STRING) = '7' THEN '4'
          ELSE '99'
        END AS Escolaridade
  FROM `basedosdados.br_ibge_pnadc.microdados`)

SELECT *
FROM Tabela
WHERE Idade >= 14 AND Idade <= 121;

 
TRADUÇÃO DA TABELA PNADC
Estamos criando uma nova tabela chamada symphone-project.projeto_final.pnad-c-ibge-final a partir dos resultados de uma consulta realizada na tabela symphone-project.projeto_final.pnad-c-ibge-novo. A nova tabela terá colunas transformadas e mapeadas conforme as instruções no código.
• CREATE TABLE symphone-project.projeto_final.pnad-c-ibge-final AS ...: Aqui estamos criando uma nova tabela chamada pnad-c-ibge-final no projeto projeto_final com o dataset symphone-project. O AS indica que os resultados da consulta seguinte serão usados para preencher essa nova tabela. Essas transformações incluem alterações nos tipos de dados e a aplicação de mapeamentos para melhor representar os dados de raça/etnia, sexo e escolaridade.
 • SELECT ...: Nesta parte estamos selecionando várias colunas da tabela symphone-project.projeto_final.pnad-c-ibge-novo e aplicando transformações e mapeamentos em algumas colunas.

A coluna "Ano" é convertida para o tipo INT64. 
A coluna "Estado" é mantida como STRING.
 A coluna "Sexo" é mapeada de '1' para 'Masculino' e '2' (presumivelmente) para 'Feminino'.
 A coluna "Raca_Cor" é mapeada de acordo com códigos para as categorias de raça/etnia, como '2' para 'Branco', '4' para 'Preto' e assim por diante.
 A coluna "Idade" é convertida para o tipo INT64.
 A coluna "Escolaridade" é mapeada de acordo com códigos para categorias de nível de escolaridade, como '1' para 'Fundamental Incompleto' e assim por diante.
CREATE TABLE `symphone-project.projeto_final.pnad-c-ibge-final` 
AS
SELECT  
        SAFE_CAST(Ano AS INT64) Ano, 
        SAFE_CAST(Estado AS STRING) Estado, 
        CASE 
          WHEN SAFE_CAST(Sexo AS STRING) = '1' THEN 'Masculino'
          ELSE 'Feminino'
        END AS Sexo, 
        CASE 
          WHEN SAFE_CAST(Raca_Cor AS STRING) = '2' THEN 'Branco' 
          WHEN SAFE_CAST(Raca_Cor AS STRING) = '4' THEN 'Preto'
          WHEN SAFE_CAST(Raca_Cor AS STRING) = '6' THEN 'Amarelo'
          WHEN SAFE_CAST(Raca_Cor AS STRING) = '8' THEN 'Pardo'
          WHEN SAFE_CAST(Raca_Cor AS STRING) = '1' THEN 'Indígena'
          ELSE 'Não Informado'
        END AS Raca_Cor, 
        SAFE_CAST(Idade AS INT64) Idade,

        CASE
          WHEN SAFE_CAST(Escolaridade AS STRING) = '1' THEN 'Fundamental Incompleto'
          WHEN SAFE_CAST(Escolaridade AS STRING) = '2' THEN 'Fundamental Completo'
          WHEN SAFE_CAST(Escolaridade AS STRING) = '3' THEN 'Médio Completo'
          WHEN SAFE_CAST(Escolaridade AS STRING) = '4' THEN 'Superior Completo'
          ELSE 'Não Informado'
        END AS Escolaridade
FROM `symphone-project.projeto_final.pnad-c-ibge-novo` ;

 

•	IPEA | Colab - Pandas e PySpark
Link do colab: https://colab.research.google.com/drive/1V1Pk1XoAJkNqbi2C6FpSYHv5Aa8CBhQk#scrollTo=brO1Mgab1l9X
 
 
 
 

 
 
 
 
 

 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 





 
 
 
 
 
 
 


 
 
 
 
 


 
 
 
 
 
 





 
 
 

 
 
 
 
 
 
 
 


 
 
 
 
 
 








 
 
 






 
 
 
 







 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 





 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 














8.	REFERÊNCIAS 
 1 – Link para a base do CAGED “microdados antigos”:
https://basedosdados.org/dataset/562b56a3-0b01-4735-a049-eeac5681f056?table=95106d6f-e36e-4fed-b8e9-99c41cd99ecf
2 – Link para a base do CAGED “microdados de movimentações”:
https://basedosdados.org/dataset/562b56a3-0b01-4735-a049-eeac5681f056?table=2245875f-d1ef-490d-be29-4f8fb2191335
3 – Link para a base do PNAD-C “microdados”:
https://basedosdados.org/dataset/9fa532fb-5681-4903-b99d-01dc45fd527a?table=a04fc85d-908a-4393-b51d-1bd517a40210
4 – Link para a base do censo IBGE “microdados_domicilio_2010”:
https://basedosdados.org/dataset/b8e8bd62-4eb9-42f9-9ffa-b5cca093f58e?table=06165a90-ac0b-4811-9cfa-45bb2e7d47fa
5 – Link para a base do IPEA “230811_cc_60_pnadc_trim_movel_e_mensalizadas”:
https://www.ipea.gov.br/cartadeconjuntura/index.php/category/mercado-de-trabalho/

